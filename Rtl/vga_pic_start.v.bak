`timescale 1ns / 1ps

module vga_pic_start(
    input  wire        vga_clk,
    input  wire        sys_rst_n,
    input  wire [9:0]  pix_x,
    input  wire [9:0]  pix_y,
    output reg  [15:0] pix_data
);

    // 屏幕分辨率
    localparam H_DISP = 640;
    localparam V_DISP = 480;

    // 原始点阵大小（逻辑像素）
    localparam BIT_W   = 80;   // 16 组 × 5 像素
    localparam BIT_H   = 16;   // 16 行
    localparam SCALE   = 4;    // 放大倍数（改成 3/5 等也可以）

    // 实际显示尺寸（放大后的像素尺寸）
    localparam CHAR_W  = BIT_W * SCALE;  // 320
    localparam CHAR_H  = BIT_H * SCALE;  // 64

    // 居中显示
    localparam CHAR_X  = (H_DISP - CHAR_W) / 2;
    localparam CHAR_Y  = (V_DISP - CHAR_H) / 2;

    // 16×16 个 5bit 数据（与你给的 C 数组一一对应）
    localparam [4:0] bitmap_bit_bytes [0:255] = '{
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b11100,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b11111,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b11100,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b01100,5'b00000,
        5'b11111,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b01100,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b01100,5'b00000,
        5'b01001,5'b10000,5'b11111,5'b10000,5'b01111,5'b00000,5'b01111,5'b00000,
        5'b01111,5'b10000,5'b01111,5'b00000,5'b11011,5'b00000,5'b11111,5'b00000,
        5'b01001,5'b10000,5'b11111,5'b10000,5'b11111,5'b00000,5'b01111,5'b00000,
        5'b01111,5'b10000,5'b01111,5'b00000,5'b11011,5'b00000,5'b11111,5'b00000,
        5'b01111,5'b00000,5'b01111,5'b10000,5'b11011,5'b10000,5'b00011,5'b00000,
        5'b01111,5'b00000,5'b11111,5'b10000,5'b01001,5'b00000,5'b01100,5'b00000,
        5'b01111,5'b10000,5'b01110,5'b00000,5'b11001,5'b10000,5'b00001,5'b00000,
        5'b01111,5'b00000,5'b11001,5'b10000,5'b01001,5'b00000,5'b01100,5'b00000,
        5'b01001,5'b10000,5'b01100,5'b00000,5'b11111,5'b10000,5'b11111,5'b00000,
        5'b01110,5'b00000,5'b11001,5'b10000,5'b01001,5'b00000,5'b01100,5'b00000,
        5'b01001,5'b10000,5'b01100,5'b00000,5'b11000,5'b00000,5'b11001,5'b00000,
        5'b01111,5'b00000,5'b11001,5'b10000,5'b01001,5'b00000,5'b01100,5'b00000,
        5'b01001,5'b10000,5'b01100,5'b00000,5'b11101,5'b10000,5'b11011,5'b00000,
        5'b01111,5'b00000,5'b11001,5'b10000,5'b01011,5'b00000,5'b01101,5'b10000,
        5'b11111,5'b10000,5'b11111,5'b00000,5'b01111,5'b10000,5'b11111,5'b10000,
        5'b11111,5'b10000,5'b01111,5'b00000,5'b01111,5'b10000,5'b01111,5'b10000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,
        5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000
    };

    always @(*) begin
        // 默认背景：黑色
        pix_data = 16'h0000;

        // 判断当前像素是否在放大后的字符区域内
        if ( (pix_x >= CHAR_X) && (pix_x < CHAR_X + CHAR_W) &&
             (pix_y >= CHAR_Y) && (pix_y < CHAR_Y + CHAR_H) ) begin
            integer sx, sy;   // 相对于字符左上角的坐标（放大后）
            integer bx, by;   // 对应到原始点阵的坐标（未放大）
            integer idx;
            integer bit_x;

            // 先得到在放大后区域中的偏移
            sx = pix_x - CHAR_X;   // 0 .. CHAR_W-1
            sy = pix_y - CHAR_Y;   // 0 .. CHAR_H-1

            // 映射回原始点阵坐标（SCALE 倍缩小）
            bx = sx / SCALE;       // 0 .. 79
            by = sy / SCALE;       // 0 .. 15

            // 每行 16 个 5bit 数据，每个数据水平 5 像素
            idx   = by * 16 + (bx / 5);  // 0 .. 255
            bit_x = bx % 5;              // 0 .. 4，决定取哪一位

            // 高位在左：bit[4] 对应最左边像素
            if (bitmap_bit_bytes[idx][4 - bit_x])
                pix_data = 16'hFFFF;     // 白色
        end
    end

endmodule