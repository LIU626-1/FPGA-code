`timescale 1ns/1ps
`default_nettype none

module tb_SM_top;

    // -------------------------------------------------
    // DUT ports
    // -------------------------------------------------
    reg         sys_clk;
    reg         sys_rst_n;   // 主复位键（低有效）
    reg         key_n;       // 用户按钮（低有效，按下=0）

    wire        h_sync;
    wire        v_sync;
    wire [15:0] rgb;

    // -------------------------------------------------
    // DUT instance
    // -------------------------------------------------
    SM_top dut (
        .sys_clk   (sys_clk),
        .sys_rst_n (sys_rst_n),
        .key_n     (key_n),
        .h_sync    (h_sync),
        .v_sync    (v_sync),
        .rgb       (rgb)
    );

    // -------------------------------------------------
    // 50 MHz 时钟: 20ns周期, 10ns翻转一次
    // -------------------------------------------------
    localparam integer CLK_HALF_NS = 10;
    initial begin
        sys_clk = 1'b0;
        forever #(CLK_HALF_NS) sys_clk = ~sys_clk;
    end

    // -------------------------------------------------
    // 任务: 模拟按键 key_n (低有效)
    // pulse_ns:  按住多久 (ns)
    // gap_ns:    松开后等待多久 (ns)
    // -------------------------------------------------
    task automatic press_key_n(input integer pulse_ns, input integer gap_ns);
    begin
        key_n = 1'b0;        // 按下
        #(pulse_ns);
        key_n = 1'b1;        // 松开
        #(gap_ns);
    end
    endtask

    // -------------------------------------------------
    // 任务: 模拟再次复位(按复位键)
    // reset_len_ns: 复位保持为0的时间
    // wait_after_ns: 复位释放后再等一段时间
    // -------------------------------------------------
    task automatic tap_reset(input integer reset_len_ns, input integer wait_after_ns);
    begin
        sys_rst_n = 1'b0;    // 拉低复位
        #(reset_len_ns);
        sys_rst_n = 1'b1;    // 放开复位
        #(wait_after_ns);
    end
    endtask

    // -------------------------------------------------
    // Stimulus
    // -------------------------------------------------
    initial begin
        // 初始化
        sys_rst_n = 1'b0; // 上电时保持复位
        key_n     = 1'b1; // 按钮默认未按，高电平(因为 *_n 代表按下=0)

        // 打开波形转储
        $dumpfile("tb_SM_top.vcd");
        $dumpvars(0, tb_SM_top);

        // 上电复位保持一小段时间，然后释放
        #200;
        sys_rst_n = 1'b1;

        // 系统跑一会儿(比如100 us)稳定下来
        #100_000;

        // -------------------------------------------------
        // 第一次按用户按钮 key_n
        // 这里给一个比较“长”的低脉冲，确保通过去抖
        // -------------------------------------------------
        press_key_n(5_000, 50_000);   // 按5us, 松手后等50us

        // 再等一会儿看看状态机有没有切到第二个画面
        #200_000;

        // -------------------------------------------------
        // 第二次按用户按钮 key_n
        // 期望再切一次状态(比如从S_MUST到S_END)
        // -------------------------------------------------
        press_key_n(5_000, 50_000);

        // 再跑一阵子观察输出
        #200_000;

        // -------------------------------------------------
        // 现在“按一下复位键”(也就是再次给 sys_rst_n 一个低脉冲)
        // 这可以当成“第二个按钮也按了”
        // -------------------------------------------------
        tap_reset(2_000, 100_000); // 复位2us，再等100us

        // 再跑一阵子，看看DUT是否回到初始状态
        #200_000;

        // 结束仿真
        $finish;
    end

endmodule

`default_nettype wire
