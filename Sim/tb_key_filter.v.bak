`timescale 1ns/1ps

module tb_key_filter;

  reg clk;
  reg rst_n;
  reg key_n;
  wire key_state;
  wire key_flag;

  key_filter #(
    .CNT_MAX(20),
    .CNT_WIDTH(5)
  ) dut (
    .clk(clk),
    .rst_n(rst_n),
    .key_n(key_n),
    .key_state(key_state),
    .key_flag(key_flag)
  );

  initial begin
    clk = 1'b0;
    forever #10 clk = ~clk;
  end

  initial begin
    $dumpfile("tb_key_filter.vcd");
    $dumpvars(0, tb_key_filter);
  end

  initial begin
    rst_n = 1'b0;
    key_n = 1'b1;

    #100;
    rst_n = 1'b1;

    #200;
    press_with_bounce(8, 5);
    #800;

    release_with_bounce(6, 4);
    #800;

    press_clean(30);
    #400;

    release_clean(30);
    #400;

    press_too_short(5);
    #400;

    press_with_bounce(10, 3);
    #1200;
    release_with_bounce(10, 3);
    #800;

    $finish;
  end

  task press_with_bounce;
    input integer bounce_times;
    input integer bounce_step_cycles;
    integer i;
    begin
      for (i = 0; i < bounce_times; i = i + 1) begin
        repeat (bounce_step_cycles) @(posedge clk);
        key_n = ~key_n;
      end
      if (key_n != 1'b0) key_n = 1'b0;
      repeat (40) @(posedge clk);
    end
  endtask

  task release_with_bounce;
    input integer bounce_times;
    input integer bounce_step_cycles;
    integer i;
    begin
      for (i = 0; i < bounce_times; i = i + 1) begin
        repeat (bounce_step_cycles) @(posedge clk);
        key_n = ~key_n;
      end
      if (key_n != 1'b1) key_n = 1'b1;
      repeat (40) @(posedge clk);
    end
  endtask

  task press_clean;
    input integer stable_cycles;
    begin
      key_n = 1'b0;
      repeat (stable_cycles) @(posedge clk);
    end
  endtask

  task release_clean;
    input integer stable_cycles;
    begin
      key_n = 1'b1;
      repeat (stable_cycles) @(posedge clk);
    end
  endtask

  task press_too_short;
    input integer hold_cycles;
    begin
      key_n = 1'b0;
      repeat (hold_cycles) @(posedge clk);
      key_n = 1'b1;
      repeat (10) @(posedge clk);
    end
  endtask

endmodule
